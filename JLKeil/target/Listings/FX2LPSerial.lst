C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 1   


C51 COMPILER V9.01, COMPILATION OF MODULE FX2LPSERIAL
OBJECT MODULE PLACED IN .\Objects\FX2LPSerial.obj
COMPILER INVOKED BY: D:\Program Files (x86)\keil\C51\BIN\C51.EXE ..\src\FX2LPSerial.c BROWSE DEBUG OBJECTEXTEND CODE LIS
                    -TINCLUDE SYMBOLS PRINT(.\Listings\FX2LPSerial.lst) PREPRINT(.\Listings\FX2LPSerial.i) OBJECT(.\Objects\FX2LPSerial.obj)

line level    source

   1          
   2          #include "fx2.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  //   File:      FX2.h
   3      =1  //   Contents:  EZ-USB FX2/FX2LP/FX1 constants, macros, datatypes, globals, and library
   4      =1  //              function prototypes.
   5      =1  //
   6      =1  // $Archive: /USB/Target/Inc/Fx2.h $
   7      =1  // $Date: 3/23/05 2:30p $
   8      =1  // $Revision: 16 $
   9      =1  //
  10      =1  //   Copyright (c) 2005 Cypress Semiconductor, All rights reserved
  11      =1  //-----------------------------------------------------------------------------
  12      =1  #ifndef FX2_H     //Header sentry
  13      =1  #define FX2_H
  14      =1  
  15      =1  #define INTERNAL_DSCR_ADDR 0x0080   // Relocate Descriptors to 0x80
  16      =1  #define bmSTRETCH 0x07
  17      =1  #define FW_STRETCH_VALUE 0x0      // Set stretch to 0 in frameworks
  18      =1  
  19      =1  #define ENABLE_7_SEG_DISPLAY
  20      =1  extern int start_7_seg_display;
  21      =1  
  22      =1  //-----------------------------------------------------------------------------
  23      =1  // Constants
  24      =1  //-----------------------------------------------------------------------------
  25      =1  #define   TRUE    1
  26      =1  #define FALSE   0
  27      =1  
  28      =1  #define bmBIT0   0x01
  29      =1  #define bmBIT1   0x02
  30      =1  #define bmBIT2   0x04
  31      =1  #define bmBIT3   0x08
  32      =1  #define bmBIT4   0x10
  33      =1  #define bmBIT5   0x20
  34      =1  #define bmBIT6   0x40
  35      =1  #define bmBIT7   0x80
  36      =1  
  37      =1  #define DEVICE_DSCR      0x01      // Descriptor type: Device
  38      =1  #define CONFIG_DSCR      0x02      // Descriptor type: Configuration
  39      =1  #define STRING_DSCR      0x03      // Descriptor type: String
  40      =1  #define INTRFC_DSCR      0x04      // Descriptor type: Interface
  41      =1  #define ENDPNT_DSCR      0x05      // Descriptor type: End Point
  42      =1  #define DEVQUAL_DSCR     0x06      // Descriptor type: Device Qualifier
  43      =1  #define OTHERSPEED_DSCR  0x07      // Descriptor type: Other Speed Configuration
  44      =1  
  45      =1  #define bmBUSPWR  bmBIT7         // Config. attribute: Bus powered
  46      =1  #define bmSELFPWR bmBIT6         // Config. attribute: Self powered
  47      =1  #define bmRWU     bmBIT5         // Config. attribute: Remote Wakeup
  48      =1  
  49      =1  #define bmEPOUT   bmBIT7
  50      =1  #define bmEPIN    0x00
  51      =1  
  52      =1  #define EP_CONTROL   0x00        // End Point type: Control
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 2   

  53      =1  #define EP_ISO       0x01        // End Point type: Isochronous
  54      =1  #define EP_BULK      0x02        // End Point type: Bulk
  55      =1  #define EP_INT       0x03        // End Point type: Interrupt
  56      =1  
  57      =1  #define SUD_SIZE            8      // Setup data packet size
  58      =1  
  59      =1  //////////////////////////////////////////////////////////////////////////////
  60      =1  //Added for HID
  61      =1  
  62      =1  #define SETUP_MASK                              0x60    //Used to mask off request type
  63      =1  #define SETUP_STANDARD_REQUEST  0               //Standard Request
  64      =1  #define SETUP_CLASS_REQUEST             0x20    //Class Request
  65      =1  #define SETUP_VENDOR_REQUEST    0x40    //Vendor Request
  66      =1  #define SETUP_RESERVED_REQUEST  0x60    //Reserved or illegal request
  67      =1  
  68      =1  //////////////////////////////////////////////////////////////////////////////
  69      =1  
  70      =1  
  71      =1  #define SC_GET_STATUS         0x00   // Setup command: Get Status
  72      =1  #define SC_CLEAR_FEATURE      0x01   // Setup command: Clear Feature
  73      =1  #define SC_RESERVED            0x02   // Setup command: Reserved
  74      =1  #define SC_SET_FEATURE         0x03   // Setup command: Set Feature
  75      =1  #define SC_SET_ADDRESS         0x05   // Setup command: Set Address
  76      =1  #define SC_GET_DESCRIPTOR      0x06   // Setup command: Get Descriptor
  77      =1  #define SC_SET_DESCRIPTOR      0x07   // Setup command: Set Descriptor
  78      =1  #define SC_GET_CONFIGURATION   0x08   // Setup command: Get Configuration
  79      =1  #define SC_SET_CONFIGURATION   0x09   // Setup command: Set Configuration
  80      =1  #define SC_GET_INTERFACE      0x0a   // Setup command: Get Interface
  81      =1  #define SC_SET_INTERFACE      0x0b   // Setup command: Set Interface
  82      =1  #define SC_SYNC_FRAME         0x0c   // Setup command: Sync Frame
  83      =1  #define SC_ANCHOR_LOAD         0xa0   // Setup command: Anchor load
  84      =1     
  85      =1  #define GD_DEVICE          0x01  // Get descriptor: Device
  86      =1  #define GD_CONFIGURATION   0x02  // Get descriptor: Configuration
  87      =1  #define GD_STRING          0x03  // Get descriptor: String
  88      =1  #define GD_INTERFACE       0x04  // Get descriptor: Interface
  89      =1  #define GD_ENDPOINT        0x05  // Get descriptor: Endpoint
  90      =1  #define GD_DEVICE_QUALIFIER 0x06  // Get descriptor: Device Qualifier
  91      =1  #define GD_OTHER_SPEED_CONFIGURATION 0x07  // Get descriptor: Other Configuration
  92      =1  #define GD_INTERFACE_POWER 0x08  // Get descriptor: Interface Power
  93      =1  #define GD_HID              0x21        // Get descriptor: HID
  94      =1  #define GD_REPORT                0x22   // Get descriptor: Report
  95      =1  
  96      =1  #define GS_DEVICE          0x80  // Get Status: Device
  97      =1  #define GS_INTERFACE       0x81  // Get Status: Interface
  98      =1  #define GS_ENDPOINT        0x82  // Get Status: End Point
  99      =1  
 100      =1  #define FT_DEVICE          0x00  // Feature: Device
 101      =1  #define FT_ENDPOINT        0x02  // Feature: End Point
 102      =1  
 103      =1  #define I2C_IDLE              0     // I2C Status: Idle mode
 104      =1  #define I2C_SENDING           1     // I2C Status: I2C is sending data
 105      =1  #define I2C_RECEIVING         2     // I2C Status: I2C is receiving data
 106      =1  #define I2C_PRIME             3     // I2C Status: I2C is receiving the first byte of a string
 107      =1  #define I2C_STOP              5     // I2C Status: I2C waiting for stop completion
 108      =1  #define I2C_BERROR            6     // I2C Status: I2C error; Bit Error
 109      =1  #define I2C_NACK              7     // I2C Status: I2C error; No Acknowledge
 110      =1  #define I2C_OK                8     // I2C positive return code
 111      =1  #define I2C_WAITSTOP          9     // I2C Status: Wait for STOP complete
 112      =1  
 113      =1  /*-----------------------------------------------------------------------------
 114      =1     Macros
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 3   

 115      =1  -----------------------------------------------------------------------------*/
 116      =1  
 117      =1  #define MSB(word)      (BYTE)(((WORD)(word) >> 8) & 0xff)
 118      =1  #define LSB(word)      (BYTE)((WORD)(word) & 0xff)
 119      =1  
 120      =1  #define SWAP_ENDIAN(word)   ((BYTE*)&word)[0] ^= ((BYTE*)&word)[1];\
 121      =1                       ((BYTE*)&word)[1] ^= ((BYTE*)&word)[0];\
 122      =1                       ((BYTE*)&word)[0] ^= ((BYTE*)&word)[1]
 123      =1  
 124      =1  #define EZUSB_IRQ_ENABLE()   EUSB = 1
 125      =1  #define EZUSB_IRQ_DISABLE()   EUSB = 0
 126      =1  #define EZUSB_IRQ_CLEAR()   EXIF &= ~0x10      // IE2_
 127      =1  
 128      =1  #define EZUSB_STALL_EP0()            EP0CS |= bmEPSTALL
 129      =1  
 130      =1  // WRITEDELAY() has been replaced by SYNCDELAY; macro in fx2sdly.h
 131      =1  // ...it is here for backwards compatibility...
 132      =1  
 133      =1  // the WRITEDELAY macro compiles to the time equivalent of 3 NOPs.
 134      =1  // It is used in the frameworks to allow for write recovery time
 135      =1  // requirements of certain registers.  This is only necessary for
 136      =1  // EZ-USB FX parts.  See the EZ-USB FX TRM for
 137      =1  // more information on write recovery time issues.
 138      =1  #define WRITEDELAY() {char writedelaydummy = 0;}
 139      =1  // if this firmware will never run on an EZ-USB FX part replace
 140      =1  // with:
 141      =1  // #define WRITEDELAY()
 142      =1  
 143      =1  // macro to reset and endpoint data toggle
 144      =1  #define EZUSB_RESET_DATA_TOGGLE(ep)     TOGCTL = (((ep & 0x80) >> 3) + (ep & 0x0F));\
 145      =1                                          TOGCTL |= bmRESETTOGGLE
 146      =1  
 147      =1  
 148      =1  #define EZUSB_ENABLE_RSMIRQ()      (EICON |= 0x20)      // Enable Resume Interrupt (EPFI_)
 149      =1  #define EZUSB_DISABLE_RSMIRQ()      (EICON &= ~0x20)   // Disable Resume Interrupt (EPFI_)
 150      =1  #define EZUSB_CLEAR_RSMIRQ()      (EICON &= ~0x10)   // Clear Resume Interrupt Flag (PFI_)
 151      =1  
 152      =1  #define EZUSB_GETI2CSTATUS()      (I2CPckt.status)
 153      =1  #define EZUSB_CLEARI2CSTATUS()      if((I2CPckt.status == I2C_BERROR) || (I2CPckt.status == I2C_NACK))\
 154      =1                                I2CPckt.status = I2C_IDLE;
 155      =1  
 156      =1  #define EZUSB_ENABLEBP()         (BREAKPT |= bmBPEN)
 157      =1  #define EZUSB_DISABLEBP()         (BREAKPT &= ~bmBPEN)
 158      =1  #define EZUSB_CLEARBP()            (BREAKPT |= bmBREAK)
 159      =1  #define EZUSB_BP(addr)            BPADDRH = (BYTE)(((WORD)addr >> 8) & 0xff);\      
 160      =1                                    BPADDRL = (BYTE)addr
 161      =1  
 162      =1  #define EZUSB_EXTWAKEUP()      (((WAKEUPCS & bmWU2) && (WAKEUPCS & bmWU2EN)) ||\
 163      =1                                  ((WAKEUPCS & bmWU) &&  (WAKEUPCS & bmWUEN)))
 164      =1  
 165      =1  #define EZUSB_HIGHSPEED()      (USBCS & bmHSM)
 166      =1  
 167      =1  //-----------------------------------------------------------------------------
 168      =1  // Datatypes
 169      =1  //-----------------------------------------------------------------------------
 170      =1  typedef unsigned char   BYTE;
 171      =1  typedef unsigned short   WORD;
 172      =1  typedef unsigned long   DWORD;
 173      =1  typedef bit            BOOL;
 174      =1  
 175      =1  #define  INT0_VECT   0
 176      =1  #define  TMR0_VECT   1
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 4   

 177      =1  #define  INT1_VECT   2
 178      =1  #define  TMR1_VECT   3
 179      =1  #define  COM0_VECT   4
 180      =1  #define  TMR2_VECT   5
 181      =1  #define  WKUP_VECT   6
 182      =1  #define  COM1_VECT   7
 183      =1  #define  USB_VECT    8
 184      =1  #define  I2C_VECT    9
 185      =1  #define  INT4_VECT   10
 186      =1  #define  INT5_VECT   11
 187      =1  #define  INT6_VECT   12
 188      =1  
 189      =1  
 190      =1  typedef struct
 191      =1  {
 192      =1     BYTE   length;
 193      =1     BYTE   type;
 194      =1  }DSCR;
 195      =1  
 196      =1  typedef struct            // Device Descriptor
 197      =1  {
 198      =1     BYTE   length;         // Descriptor length ( = sizeof(DEVICEDSCR) )
 199      =1     BYTE   type;         // Decriptor type (Device = 1)
 200      =1     BYTE   spec_ver_minor;   // Specification Version (BCD) minor
 201      =1     BYTE   spec_ver_major;   // Specification Version (BCD) major
 202      =1     BYTE   dev_class;      // Device class
 203      =1     BYTE   sub_class;      // Device sub-class
 204      =1     BYTE   protocol;      // Device sub-sub-class
 205      =1     BYTE   max_packet;      // Maximum packet size
 206      =1     WORD   vendor_id;      // Vendor ID
 207      =1     WORD   product_id;      // Product ID
 208      =1     WORD   version_id;      // Product version ID
 209      =1     BYTE   mfg_str;      // Manufacturer string index
 210      =1     BYTE   prod_str;      // Product string index
 211      =1     BYTE   serialnum_str;   // Serial number string index
 212      =1     BYTE   configs;      // Number of configurations
 213      =1  }DEVICEDSCR;
 214      =1  
 215      =1  typedef struct            // Device Qualifier Descriptor
 216      =1  {
 217      =1     BYTE   length;         // Descriptor length ( = sizeof(DEVICEQUALDSCR) )
 218      =1     BYTE   type;         // Decriptor type (Device Qualifier = 6)
 219      =1     BYTE   spec_ver_minor;   // Specification Version (BCD) minor
 220      =1     BYTE   spec_ver_major;   // Specification Version (BCD) major
 221      =1     BYTE   dev_class;      // Device class
 222      =1     BYTE   sub_class;      // Device sub-class
 223      =1     BYTE   protocol;      // Device sub-sub-class
 224      =1     BYTE   max_packet;      // Maximum packet size
 225      =1     BYTE   configs;      // Number of configurations
 226      =1     BYTE  reserved0;
 227      =1  }DEVICEQUALDSCR;
 228      =1  
 229      =1  typedef struct
 230      =1  {
 231      =1     BYTE   length;         // Configuration length ( = sizeof(CONFIGDSCR) )
 232      =1     BYTE   type;         // Descriptor type (Configuration = 2)
 233      =1     WORD   config_len;      // Configuration + End Points length
 234      =1     BYTE   interfaces;      // Number of interfaces
 235      =1     BYTE   index;         // Configuration number
 236      =1     BYTE   config_str;      // Configuration string
 237      =1     BYTE   attrib;         // Attributes (b7 - buspwr, b6 - selfpwr, b5 - rwu
 238      =1     BYTE   power;         // Power requirement (div 2 ma)
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 5   

 239      =1  }CONFIGDSCR;
 240      =1  
 241      =1  typedef struct
 242      =1  {
 243      =1     BYTE   length;         // Interface descriptor length ( - sizeof(INTRFCDSCR) )
 244      =1     BYTE   type;         // Descriptor type (Interface = 4)
 245      =1     BYTE   index;         // Zero-based index of this interface
 246      =1     BYTE   alt_setting;   // Alternate setting
 247      =1     BYTE   ep_cnt;         // Number of end points 
 248      =1     BYTE   class;         // Interface class
 249      =1     BYTE   sub_class;      // Interface sub class
 250      =1     BYTE   protocol;      // Interface sub sub class
 251      =1     BYTE   interface_str;   // Interface descriptor string index
 252      =1  }INTRFCDSCR;
 253      =1  
 254      =1  typedef struct
 255      =1  {
 256      =1     BYTE   length;         // End point descriptor length ( = sizeof(ENDPNTDSCR) )
 257      =1     BYTE   type;         // Descriptor type (End point = 5)
 258      =1     BYTE   addr;         // End point address
 259      =1     BYTE   ep_type;      // End point type
 260      =1     BYTE   mp_L;         // Maximum packet size
 261      =1     BYTE   mp_H;
 262      =1     BYTE   interval;      // Interrupt polling interval
 263      =1  }ENDPNTDSCR;
 264      =1  
 265      =1  typedef struct
 266      =1  {
 267      =1     BYTE   length;         // String descriptor length
 268      =1     BYTE   type;         // Descriptor type
 269      =1  }STRINGDSCR;
 270      =1  
 271      =1  typedef struct
 272      =1  {
 273      =1     BYTE   cntrl;         // End point control register
 274      =1     BYTE   bytes;         // End point buffer byte count
 275      =1  }EPIOC;
 276      =1  
 277      =1  typedef struct 
 278      =1  {
 279      =1     BYTE   length;
 280      =1     BYTE   *dat;
 281      =1     BYTE   count;
 282      =1     BYTE   status;
 283      =1  }I2CPCKT;
 284      =1  
 285      =1  //-----------------------------------------------------------------------------
 286      =1  // Globals
 287      =1  //-----------------------------------------------------------------------------
 288      =1  extern code BYTE   USB_AutoVector;
 289      =1  
 290      =1  extern WORD   pDeviceDscr;
 291      =1  extern WORD   pDeviceQualDscr;
 292      =1  extern WORD       pHighSpeedConfigDscr;
 293      =1  extern WORD       pFullSpeedConfigDscr; 
 294      =1  extern WORD   pConfigDscr;
 295      =1  extern WORD   pOtherConfigDscr;
 296      =1  extern WORD   pStringDscr;
 297      =1  
 298      =1  extern code DEVICEDSCR        DeviceDscr;
 299      =1  extern code DEVICEQUALDSCR    DeviceQualDscr;
 300      =1  extern code CONFIGDSCR        HighSpeedConfigDscr;
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 6   

 301      =1  extern code CONFIGDSCR        FullSpeedConfigDscr;
 302      =1  extern code STRINGDSCR        StringDscr;
 303      =1  extern code DSCR              UserDscr;
 304      =1  
 305      =1  extern I2CPCKT   I2CPckt;
 306      =1  
 307      =1  //-----------------------------------------------------------------------------
 308      =1  // Function Prototypes
 309      =1  //-----------------------------------------------------------------------------
 310      =1  
 311      =1  extern void EZUSB_Renum(void);
 312      =1  extern void EZUSB_Discon(BOOL renum);
 313      =1  
 314      =1  extern void EZUSB_Susp(void);
 315      =1  extern void EZUSB_Resume(void);
 316      =1  
 317      =1  extern void EZUSB_Delay1ms(void);
 318      =1  extern void EZUSB_Delay(WORD ms);
 319      =1  
 320      =1  extern CONFIGDSCR xdata*   EZUSB_GetConfigDscr(BYTE ConfigIdx);
 321      =1  extern INTRFCDSCR xdata*   EZUSB_GetIntrfcDscr(BYTE ConfigIdx, BYTE IntrfcIdx, BYTE AltSetting);
 322      =1  extern STRINGDSCR xdata*   EZUSB_GetStringDscr(BYTE StrIdx);
 323      =1  extern DSCR xdata*      EZUSB_GetDscr(BYTE index, DSCR* dscr, BYTE type);
 324      =1  
 325      =1  extern void EZUSB_InitI2C(void);
 326      =1  extern BOOL EZUSB_WriteI2C_(BYTE addr, BYTE length, BYTE xdata *dat);
 327      =1  extern BOOL EZUSB_ReadI2C_(BYTE addr, BYTE length, BYTE xdata *dat);
 328      =1  extern BOOL EZUSB_WriteI2C(BYTE addr, BYTE length, BYTE xdata *dat);
 329      =1  extern BOOL EZUSB_ReadI2C(BYTE addr, BYTE length, BYTE xdata *dat);
 330      =1  extern void EZUSB_WaitForEEPROMWrite(BYTE addr);
 331      =1  
 332      =1  extern void modify_endpoint_stall(BYTE epid, BYTE stall);
 333      =1  
 334      =1  #endif   // FX2_H
   3          #include "fx2regs.h"
   1      =1  //-----------------------------------------------------------------------------
   2      =1  //   File:      FX2regs.h
   3      =1  //   Contents:   EZ-USB FX2/FX2LP/FX1 register declarations and bit mask definitions.
   4      =1  //
   5      =1  // $Archive: /USB/Target/Inc/fx2regs.h $
   6      =1  // $Date: 4/13/05 4:29p $
   7      =1  // $Revision: 42 $
   8      =1  //
   9      =1  //
  10      =1  //   Copyright (c) 2005 Cypress Semiconductor, All rights reserved
  11      =1  //-----------------------------------------------------------------------------
  12      =1  
  13      =1  #ifndef FX2REGS_H   /* Header Sentry */
  14      =1  #define FX2REGS_H
  15      =1  
  16      =1  //-----------------------------------------------------------------------------
  17      =1  // FX2/FX2LP/FX1 Related Register Assignments
  18      =1  //-----------------------------------------------------------------------------
  19      =1  
  20      =1  // The Ez-USB FX2/FX2LP/FX1 registers are defined here. We use fx2regs.h for register 
  21      =1  // address allocation by using "#define ALLOCATE_EXTERN". 
  22      =1  // When using "#define ALLOCATE_EXTERN", you get (for instance): 
  23      =1  // xdata volatile BYTE OUT7BUF[64]   _at_   0x7B40;
  24      =1  // Such lines are created from FX2.h by using the preprocessor. 
  25      =1  // Incidently, these lines will not generate any space in the resulting hex 
  26      =1  // file; they just bind the symbols to the addresses for compilation. 
  27      =1  // You just need to put "#define ALLOCATE_EXTERN" in your main program file; 
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 7   

  28      =1  // i.e. fw.c or a stand-alone C source file. 
  29      =1  // Without "#define ALLOCATE_EXTERN", you just get the external reference: 
  30      =1  // extern xdata volatile BYTE OUT7BUF[64]   ;//   0x7B40;
  31      =1  // This uses the concatenation operator "##" to insert a comment "//" 
  32      =1  // to cut off the end of the line, "_at_   0x7B40;", which is not wanted.
  33      =1  
  34      =1  #ifdef ALLOCATE_EXTERN
           =1 #define EXTERN
           =1 #define _AT_ _at_
           =1 #else
  38      =1  #define EXTERN extern
  39      =1  #define _AT_ ;/ ## /
  40      =1  #endif
  41      =1  
  42      =1  EXTERN xdata volatile BYTE GPIF_WAVE_DATA    _AT_ 0xE400;
  43      =1  EXTERN xdata volatile BYTE RES_WAVEDATA_END  _AT_ 0xE480;
  44      =1  
  45      =1  // General Configuration
  46      =1  
  47      =1  EXTERN xdata volatile BYTE CPUCS             _AT_ 0xE600;  // Control & Status
  48      =1  EXTERN xdata volatile BYTE IFCONFIG          _AT_ 0xE601;  // Interface Configuration
  49      =1  EXTERN xdata volatile BYTE PINFLAGSAB        _AT_ 0xE602;  // FIFO FLAGA and FLAGB Assignments
  50      =1  EXTERN xdata volatile BYTE PINFLAGSCD        _AT_ 0xE603;  // FIFO FLAGC and FLAGD Assignments
  51      =1  EXTERN xdata volatile BYTE FIFORESET         _AT_ 0xE604;  // Restore FIFOS to default state
  52      =1  EXTERN xdata volatile BYTE BREAKPT           _AT_ 0xE605;  // Breakpoint
  53      =1  EXTERN xdata volatile BYTE BPADDRH           _AT_ 0xE606;  // Breakpoint Address H
  54      =1  EXTERN xdata volatile BYTE BPADDRL           _AT_ 0xE607;  // Breakpoint Address L
  55      =1  EXTERN xdata volatile BYTE UART230           _AT_ 0xE608;  // 230 Kbaud clock for T0,T1,T2
  56      =1  EXTERN xdata volatile BYTE FIFOPINPOLAR      _AT_ 0xE609;  // FIFO polarities
  57      =1  EXTERN xdata volatile BYTE REVID             _AT_ 0xE60A;  // Chip Revision
  58      =1  EXTERN xdata volatile BYTE REVCTL            _AT_ 0xE60B;  // Chip Revision Control
  59      =1  
  60      =1  // Endpoint Configuration
  61      =1  
  62      =1  EXTERN xdata volatile BYTE EP1OUTCFG         _AT_ 0xE610;  // Endpoint 1-OUT Configuration
  63      =1  EXTERN xdata volatile BYTE EP1INCFG          _AT_ 0xE611;  // Endpoint 1-IN Configuration
  64      =1  EXTERN xdata volatile BYTE EP2CFG            _AT_ 0xE612;  // Endpoint 2 Configuration
  65      =1  EXTERN xdata volatile BYTE EP4CFG            _AT_ 0xE613;  // Endpoint 4 Configuration
  66      =1  EXTERN xdata volatile BYTE EP6CFG            _AT_ 0xE614;  // Endpoint 6 Configuration
  67      =1  EXTERN xdata volatile BYTE EP8CFG            _AT_ 0xE615;  // Endpoint 8 Configuration
  68      =1  EXTERN xdata volatile BYTE EP2FIFOCFG        _AT_ 0xE618;  // Endpoint 2 FIFO configuration
  69      =1  EXTERN xdata volatile BYTE EP4FIFOCFG        _AT_ 0xE619;  // Endpoint 4 FIFO configuration
  70      =1  EXTERN xdata volatile BYTE EP6FIFOCFG        _AT_ 0xE61A;  // Endpoint 6 FIFO configuration
  71      =1  EXTERN xdata volatile BYTE EP8FIFOCFG        _AT_ 0xE61B;  // Endpoint 8 FIFO configuration
  72      =1  EXTERN xdata volatile BYTE EP2AUTOINLENH     _AT_ 0xE620;  // Endpoint 2 Packet Length H (IN only)
  73      =1  EXTERN xdata volatile BYTE EP2AUTOINLENL     _AT_ 0xE621;  // Endpoint 2 Packet Length L (IN only)
  74      =1  EXTERN xdata volatile BYTE EP4AUTOINLENH     _AT_ 0xE622;  // Endpoint 4 Packet Length H (IN only)
  75      =1  EXTERN xdata volatile BYTE EP4AUTOINLENL     _AT_ 0xE623;  // Endpoint 4 Packet Length L (IN only)
  76      =1  EXTERN xdata volatile BYTE EP6AUTOINLENH     _AT_ 0xE624;  // Endpoint 6 Packet Length H (IN only)
  77      =1  EXTERN xdata volatile BYTE EP6AUTOINLENL     _AT_ 0xE625;  // Endpoint 6 Packet Length L (IN only)
  78      =1  EXTERN xdata volatile BYTE EP8AUTOINLENH     _AT_ 0xE626;  // Endpoint 8 Packet Length H (IN only)
  79      =1  EXTERN xdata volatile BYTE EP8AUTOINLENL     _AT_ 0xE627;  // Endpoint 8 Packet Length L (IN only)
  80      =1  EXTERN xdata volatile BYTE EP2FIFOPFH        _AT_ 0xE630;  // EP2 Programmable Flag trigger H
  81      =1  EXTERN xdata volatile BYTE EP2FIFOPFL        _AT_ 0xE631;  // EP2 Programmable Flag trigger L
  82      =1  EXTERN xdata volatile BYTE EP4FIFOPFH        _AT_ 0xE632;  // EP4 Programmable Flag trigger H
  83      =1  EXTERN xdata volatile BYTE EP4FIFOPFL        _AT_ 0xE633;  // EP4 Programmable Flag trigger L
  84      =1  EXTERN xdata volatile BYTE EP6FIFOPFH        _AT_ 0xE634;  // EP6 Programmable Flag trigger H
  85      =1  EXTERN xdata volatile BYTE EP6FIFOPFL        _AT_ 0xE635;  // EP6 Programmable Flag trigger L
  86      =1  EXTERN xdata volatile BYTE EP8FIFOPFH        _AT_ 0xE636;  // EP8 Programmable Flag trigger H
  87      =1  EXTERN xdata volatile BYTE EP8FIFOPFL        _AT_ 0xE637;  // EP8 Programmable Flag trigger L
  88      =1  EXTERN xdata volatile BYTE EP2ISOINPKTS      _AT_ 0xE640;  // EP2 (if ISO) IN Packets per frame (1-3)
  89      =1  EXTERN xdata volatile BYTE EP4ISOINPKTS      _AT_ 0xE641;  // EP4 (if ISO) IN Packets per frame (1-3)
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 8   

  90      =1  EXTERN xdata volatile BYTE EP6ISOINPKTS      _AT_ 0xE642;  // EP6 (if ISO) IN Packets per frame (1-3)
  91      =1  EXTERN xdata volatile BYTE EP8ISOINPKTS      _AT_ 0xE643;  // EP8 (if ISO) IN Packets per frame (1-3)
  92      =1  EXTERN xdata volatile BYTE INPKTEND          _AT_ 0xE648;  // Force IN Packet End
  93      =1  EXTERN xdata volatile BYTE OUTPKTEND         _AT_ 0xE649;  // Force OUT Packet End
  94      =1  
  95      =1  // Interrupts
  96      =1  
  97      =1  EXTERN xdata volatile BYTE EP2FIFOIE         _AT_ 0xE650;  // Endpoint 2 Flag Interrupt Enable
  98      =1  EXTERN xdata volatile BYTE EP2FIFOIRQ        _AT_ 0xE651;  // Endpoint 2 Flag Interrupt Request
  99      =1  EXTERN xdata volatile BYTE EP4FIFOIE         _AT_ 0xE652;  // Endpoint 4 Flag Interrupt Enable
 100      =1  EXTERN xdata volatile BYTE EP4FIFOIRQ        _AT_ 0xE653;  // Endpoint 4 Flag Interrupt Request
 101      =1  EXTERN xdata volatile BYTE EP6FIFOIE         _AT_ 0xE654;  // Endpoint 6 Flag Interrupt Enable
 102      =1  EXTERN xdata volatile BYTE EP6FIFOIRQ        _AT_ 0xE655;  // Endpoint 6 Flag Interrupt Request
 103      =1  EXTERN xdata volatile BYTE EP8FIFOIE         _AT_ 0xE656;  // Endpoint 8 Flag Interrupt Enable
 104      =1  EXTERN xdata volatile BYTE EP8FIFOIRQ        _AT_ 0xE657;  // Endpoint 8 Flag Interrupt Request
 105      =1  EXTERN xdata volatile BYTE IBNIE             _AT_ 0xE658;  // IN-BULK-NAK Interrupt Enable
 106      =1  EXTERN xdata volatile BYTE IBNIRQ            _AT_ 0xE659;  // IN-BULK-NAK interrupt Request
 107      =1  EXTERN xdata volatile BYTE NAKIE             _AT_ 0xE65A;  // Endpoint Ping NAK interrupt Enable
 108      =1  EXTERN xdata volatile BYTE NAKIRQ            _AT_ 0xE65B;  // Endpoint Ping NAK interrupt Request
 109      =1  EXTERN xdata volatile BYTE USBIE             _AT_ 0xE65C;  // USB Int Enables
 110      =1  EXTERN xdata volatile BYTE USBIRQ            _AT_ 0xE65D;  // USB Interrupt Requests
 111      =1  EXTERN xdata volatile BYTE EPIE              _AT_ 0xE65E;  // Endpoint Interrupt Enables
 112      =1  EXTERN xdata volatile BYTE EPIRQ             _AT_ 0xE65F;  // Endpoint Interrupt Requests
 113      =1  EXTERN xdata volatile BYTE GPIFIE            _AT_ 0xE660;  // GPIF Interrupt Enable
 114      =1  EXTERN xdata volatile BYTE GPIFIRQ           _AT_ 0xE661;  // GPIF Interrupt Request
 115      =1  EXTERN xdata volatile BYTE USBERRIE          _AT_ 0xE662;  // USB Error Interrupt Enables
 116      =1  EXTERN xdata volatile BYTE USBERRIRQ         _AT_ 0xE663;  // USB Error Interrupt Requests
 117      =1  EXTERN xdata volatile BYTE ERRCNTLIM         _AT_ 0xE664;  // USB Error counter and limit
 118      =1  EXTERN xdata volatile BYTE CLRERRCNT         _AT_ 0xE665;  // Clear Error Counter EC[3..0]
 119      =1  EXTERN xdata volatile BYTE INT2IVEC          _AT_ 0xE666;  // Interupt 2 (USB) Autovector
 120      =1  EXTERN xdata volatile BYTE INT4IVEC          _AT_ 0xE667;  // Interupt 4 (FIFOS & GPIF) Autovector
 121      =1  EXTERN xdata volatile BYTE INTSETUP          _AT_ 0xE668;  // Interrupt 2&4 Setup
 122      =1  
 123      =1  // Input/Output
 124      =1  
 125      =1  EXTERN xdata volatile BYTE PORTACFG          _AT_ 0xE670;  // I/O PORTA Alternate Configuration
 126      =1  EXTERN xdata volatile BYTE PORTCCFG          _AT_ 0xE671;  // I/O PORTC Alternate Configuration
 127      =1  EXTERN xdata volatile BYTE PORTECFG          _AT_ 0xE672;  // I/O PORTE Alternate Configuration
 128      =1  EXTERN xdata volatile BYTE I2CS              _AT_ 0xE678;  // Control & Status
 129      =1  EXTERN xdata volatile BYTE I2DAT             _AT_ 0xE679;  // Data
 130      =1  EXTERN xdata volatile BYTE I2CTL             _AT_ 0xE67A;  // I2C Control
 131      =1  EXTERN xdata volatile BYTE XAUTODAT1         _AT_ 0xE67B;  // Autoptr1 MOVX access
 132      =1  EXTERN xdata volatile BYTE XAUTODAT2         _AT_ 0xE67C;  // Autoptr2 MOVX access
 133      =1  
 134      =1  #define EXTAUTODAT1 XAUTODAT1
 135      =1  #define EXTAUTODAT2 XAUTODAT2
 136      =1  
 137      =1  // USB Control
 138      =1  
 139      =1  EXTERN xdata volatile BYTE USBCS             _AT_ 0xE680;  // USB Control & Status
 140      =1  EXTERN xdata volatile BYTE SUSPEND           _AT_ 0xE681;  // Put chip into suspend
 141      =1  EXTERN xdata volatile BYTE WAKEUPCS          _AT_ 0xE682;  // Wakeup source and polarity
 142      =1  EXTERN xdata volatile BYTE TOGCTL            _AT_ 0xE683;  // Toggle Control
 143      =1  EXTERN xdata volatile BYTE USBFRAMEH         _AT_ 0xE684;  // USB Frame count H
 144      =1  EXTERN xdata volatile BYTE USBFRAMEL         _AT_ 0xE685;  // USB Frame count L
 145      =1  EXTERN xdata volatile BYTE MICROFRAME        _AT_ 0xE686;  // Microframe count, 0-7
 146      =1  EXTERN xdata volatile BYTE FNADDR            _AT_ 0xE687;  // USB Function address
 147      =1  
 148      =1  // Endpoints
 149      =1  
 150      =1  EXTERN xdata volatile BYTE EP0BCH            _AT_ 0xE68A;  // Endpoint 0 Byte Count H
 151      =1  EXTERN xdata volatile BYTE EP0BCL            _AT_ 0xE68B;  // Endpoint 0 Byte Count L
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 9   

 152      =1  EXTERN xdata volatile BYTE EP1OUTBC          _AT_ 0xE68D;  // Endpoint 1 OUT Byte Count
 153      =1  EXTERN xdata volatile BYTE EP1INBC           _AT_ 0xE68F;  // Endpoint 1 IN Byte Count
 154      =1  EXTERN xdata volatile BYTE EP2BCH            _AT_ 0xE690;  // Endpoint 2 Byte Count H
 155      =1  EXTERN xdata volatile BYTE EP2BCL            _AT_ 0xE691;  // Endpoint 2 Byte Count L
 156      =1  EXTERN xdata volatile BYTE EP4BCH            _AT_ 0xE694;  // Endpoint 4 Byte Count H
 157      =1  EXTERN xdata volatile BYTE EP4BCL            _AT_ 0xE695;  // Endpoint 4 Byte Count L
 158      =1  EXTERN xdata volatile BYTE EP6BCH            _AT_ 0xE698;  // Endpoint 6 Byte Count H
 159      =1  EXTERN xdata volatile BYTE EP6BCL            _AT_ 0xE699;  // Endpoint 6 Byte Count L
 160      =1  EXTERN xdata volatile BYTE EP8BCH            _AT_ 0xE69C;  // Endpoint 8 Byte Count H
 161      =1  EXTERN xdata volatile BYTE EP8BCL            _AT_ 0xE69D;  // Endpoint 8 Byte Count L
 162      =1  EXTERN xdata volatile BYTE EP0CS             _AT_ 0xE6A0;  // Endpoint  Control and Status
 163      =1  EXTERN xdata volatile BYTE EP1OUTCS          _AT_ 0xE6A1;  // Endpoint 1 OUT Control and Status
 164      =1  EXTERN xdata volatile BYTE EP1INCS           _AT_ 0xE6A2;  // Endpoint 1 IN Control and Status
 165      =1  EXTERN xdata volatile BYTE EP2CS             _AT_ 0xE6A3;  // Endpoint 2 Control and Status
 166      =1  EXTERN xdata volatile BYTE EP4CS             _AT_ 0xE6A4;  // Endpoint 4 Control and Status
 167      =1  EXTERN xdata volatile BYTE EP6CS             _AT_ 0xE6A5;  // Endpoint 6 Control and Status
 168      =1  EXTERN xdata volatile BYTE EP8CS             _AT_ 0xE6A6;  // Endpoint 8 Control and Status
 169      =1  EXTERN xdata volatile BYTE EP2FIFOFLGS       _AT_ 0xE6A7;  // Endpoint 2 Flags
 170      =1  EXTERN xdata volatile BYTE EP4FIFOFLGS       _AT_ 0xE6A8;  // Endpoint 4 Flags
 171      =1  EXTERN xdata volatile BYTE EP6FIFOFLGS       _AT_ 0xE6A9;  // Endpoint 6 Flags
 172      =1  EXTERN xdata volatile BYTE EP8FIFOFLGS       _AT_ 0xE6AA;  // Endpoint 8 Flags
 173      =1  EXTERN xdata volatile BYTE EP2FIFOBCH        _AT_ 0xE6AB;  // EP2 FIFO total byte count H
 174      =1  EXTERN xdata volatile BYTE EP2FIFOBCL        _AT_ 0xE6AC;  // EP2 FIFO total byte count L
 175      =1  EXTERN xdata volatile BYTE EP4FIFOBCH        _AT_ 0xE6AD;  // EP4 FIFO total byte count H
 176      =1  EXTERN xdata volatile BYTE EP4FIFOBCL        _AT_ 0xE6AE;  // EP4 FIFO total byte count L
 177      =1  EXTERN xdata volatile BYTE EP6FIFOBCH        _AT_ 0xE6AF;  // EP6 FIFO total byte count H
 178      =1  EXTERN xdata volatile BYTE EP6FIFOBCL        _AT_ 0xE6B0;  // EP6 FIFO total byte count L
 179      =1  EXTERN xdata volatile BYTE EP8FIFOBCH        _AT_ 0xE6B1;  // EP8 FIFO total byte count H
 180      =1  EXTERN xdata volatile BYTE EP8FIFOBCL        _AT_ 0xE6B2;  // EP8 FIFO total byte count L
 181      =1  EXTERN xdata volatile BYTE SUDPTRH           _AT_ 0xE6B3;  // Setup Data Pointer high address byte
 182      =1  EXTERN xdata volatile BYTE SUDPTRL           _AT_ 0xE6B4;  // Setup Data Pointer low address byte
 183      =1  EXTERN xdata volatile BYTE SUDPTRCTL         _AT_ 0xE6B5;  // Setup Data Pointer Auto Mode
 184      =1  EXTERN xdata volatile BYTE SETUPDAT[8]       _AT_ 0xE6B8;  // 8 bytes of SETUP data
 185      =1  
 186      =1  // GPIF
 187      =1  
 188      =1  EXTERN xdata volatile BYTE GPIFWFSELECT      _AT_ 0xE6C0;  // Waveform Selector
 189      =1  EXTERN xdata volatile BYTE GPIFIDLECS        _AT_ 0xE6C1;  // GPIF Done, GPIF IDLE drive mode
 190      =1  EXTERN xdata volatile BYTE GPIFIDLECTL       _AT_ 0xE6C2;  // Inactive Bus, CTL states
 191      =1  EXTERN xdata volatile BYTE GPIFCTLCFG        _AT_ 0xE6C3;  // CTL OUT pin drive
 192      =1  EXTERN xdata volatile BYTE GPIFADRH          _AT_ 0xE6C4;  // GPIF Address H
 193      =1  EXTERN xdata volatile BYTE GPIFADRL          _AT_ 0xE6C5;  // GPIF Address L
 194      =1  
 195      =1  EXTERN xdata volatile BYTE GPIFTCB3          _AT_ 0xE6CE;  // GPIF Transaction Count Byte 3
 196      =1  EXTERN xdata volatile BYTE GPIFTCB2          _AT_ 0xE6CF;  // GPIF Transaction Count Byte 2
 197      =1  EXTERN xdata volatile BYTE GPIFTCB1          _AT_ 0xE6D0;  // GPIF Transaction Count Byte 1
 198      =1  EXTERN xdata volatile BYTE GPIFTCB0          _AT_ 0xE6D1;  // GPIF Transaction Count Byte 0
 199      =1  
 200      =1  #define EP2GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 201      =1  #define EP2GPIFTCL GPIFTCB0   // 
 202      =1  #define EP4GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 203      =1  #define EP4GPIFTCL GPIFTCB0   // 
 204      =1  #define EP6GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 205      =1  #define EP6GPIFTCL GPIFTCB0   // 
 206      =1  #define EP8GPIFTCH GPIFTCB1   // these are here for backwards compatibility
 207      =1  #define EP8GPIFTCL GPIFTCB0   // 
 208      =1  
 209      =1  EXTERN xdata volatile BYTE EP2GPIFFLGSEL     _AT_ 0xE6D2;  // EP2 GPIF Flag select
 210      =1  EXTERN xdata volatile BYTE EP2GPIFPFSTOP     _AT_ 0xE6D3;  // Stop GPIF EP2 transaction on prog. flag
 211      =1  EXTERN xdata volatile BYTE EP2GPIFTRIG       _AT_ 0xE6D4;  // EP2 FIFO Trigger
 212      =1  EXTERN xdata volatile BYTE EP4GPIFFLGSEL     _AT_ 0xE6DA;  // EP4 GPIF Flag select
 213      =1  EXTERN xdata volatile BYTE EP4GPIFPFSTOP     _AT_ 0xE6DB;  // Stop GPIF EP4 transaction on prog. flag
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 10  

 214      =1  EXTERN xdata volatile BYTE EP4GPIFTRIG       _AT_ 0xE6DC;  // EP4 FIFO Trigger
 215      =1  EXTERN xdata volatile BYTE EP6GPIFFLGSEL     _AT_ 0xE6E2;  // EP6 GPIF Flag select
 216      =1  EXTERN xdata volatile BYTE EP6GPIFPFSTOP     _AT_ 0xE6E3;  // Stop GPIF EP6 transaction on prog. flag
 217      =1  EXTERN xdata volatile BYTE EP6GPIFTRIG       _AT_ 0xE6E4;  // EP6 FIFO Trigger
 218      =1  EXTERN xdata volatile BYTE EP8GPIFFLGSEL     _AT_ 0xE6EA;  // EP8 GPIF Flag select
 219      =1  EXTERN xdata volatile BYTE EP8GPIFPFSTOP     _AT_ 0xE6EB;  // Stop GPIF EP8 transaction on prog. flag
 220      =1  EXTERN xdata volatile BYTE EP8GPIFTRIG       _AT_ 0xE6EC;  // EP8 FIFO Trigger
 221      =1  EXTERN xdata volatile BYTE XGPIFSGLDATH      _AT_ 0xE6F0;  // GPIF Data H (16-bit mode only)
 222      =1  EXTERN xdata volatile BYTE XGPIFSGLDATLX     _AT_ 0xE6F1;  // Read/Write GPIF Data L & trigger transac
 223      =1  EXTERN xdata volatile BYTE XGPIFSGLDATLNOX   _AT_ 0xE6F2;  // Read GPIF Data L, no transac trigger
 224      =1  EXTERN xdata volatile BYTE GPIFREADYCFG      _AT_ 0xE6F3;  // Internal RDY,Sync/Async, RDY5CFG
 225      =1  EXTERN xdata volatile BYTE GPIFREADYSTAT     _AT_ 0xE6F4;  // RDY pin states
 226      =1  EXTERN xdata volatile BYTE GPIFABORT         _AT_ 0xE6F5;  // Abort GPIF cycles
 227      =1  
 228      =1  // UDMA
 229      =1  
 230      =1  EXTERN xdata volatile BYTE FLOWSTATE         _AT_  0xE6C6; //Defines GPIF flow state
 231      =1  EXTERN xdata volatile BYTE FLOWLOGIC         _AT_  0xE6C7; //Defines flow/hold decision criteria
 232      =1  EXTERN xdata volatile BYTE FLOWEQ0CTL        _AT_  0xE6C8; //CTL states during active flow state
 233      =1  EXTERN xdata volatile BYTE FLOWEQ1CTL        _AT_  0xE6C9; //CTL states during hold flow state
 234      =1  EXTERN xdata volatile BYTE FLOWHOLDOFF       _AT_  0xE6CA;
 235      =1  EXTERN xdata volatile BYTE FLOWSTB           _AT_  0xE6CB; //CTL/RDY Signal to use as master data strobe 
 236      =1  EXTERN xdata volatile BYTE FLOWSTBEDGE       _AT_  0xE6CC; //Defines active master strobe edge
 237      =1  EXTERN xdata volatile BYTE FLOWSTBHPERIOD    _AT_  0xE6CD; //Half Period of output master strobe
 238      =1  EXTERN xdata volatile BYTE GPIFHOLDAMOUNT    _AT_  0xE60C; //Data delay shift 
 239      =1  EXTERN xdata volatile BYTE UDMACRCH          _AT_  0xE67D; //CRC Upper byte
 240      =1  EXTERN xdata volatile BYTE UDMACRCL          _AT_  0xE67E; //CRC Lower byte
 241      =1  EXTERN xdata volatile BYTE UDMACRCQUAL       _AT_  0xE67F; //UDMA In only, host terminated use only
 242      =1  
 243      =1  
 244      =1  // Debug/Test
 245      =1  // The following registers are for Cypress's internal testing purposes only.
 246      =1  // These registers are not documented in the datasheet or the Technical Reference
 247      =1  // Manual as they were not designed for end user application usage 
 248      =1  EXTERN xdata volatile BYTE DBUG              _AT_ 0xE6F8;  // Debug
 249      =1  EXTERN xdata volatile BYTE TESTCFG           _AT_ 0xE6F9;  // Test configuration
 250      =1  EXTERN xdata volatile BYTE USBTEST           _AT_ 0xE6FA;  // USB Test Modes
 251      =1  EXTERN xdata volatile BYTE CT1               _AT_ 0xE6FB;  // Chirp Test--Override
 252      =1  EXTERN xdata volatile BYTE CT2               _AT_ 0xE6FC;  // Chirp Test--FSM
 253      =1  EXTERN xdata volatile BYTE CT3               _AT_ 0xE6FD;  // Chirp Test--Control Signals
 254      =1  EXTERN xdata volatile BYTE CT4               _AT_ 0xE6FE;  // Chirp Test--Inputs
 255      =1  
 256      =1  // Endpoint Buffers
 257      =1  
 258      =1  EXTERN xdata volatile BYTE EP0BUF[64]        _AT_ 0xE740;  // EP0 IN-OUT buffer
 259      =1  EXTERN xdata volatile BYTE EP1OUTBUF[64]     _AT_ 0xE780;  // EP1-OUT buffer
 260      =1  EXTERN xdata volatile BYTE EP1INBUF[64]      _AT_ 0xE7C0;  // EP1-IN buffer
 261      =1  EXTERN xdata volatile BYTE EP2FIFOBUF[1024]  _AT_ 0xF000;  // 512/1024-byte EP2 buffer (IN or OUT)
 262      =1  EXTERN xdata volatile BYTE EP4FIFOBUF[1024]  _AT_ 0xF400;  // 512 byte EP4 buffer (IN or OUT)
 263      =1  EXTERN xdata volatile BYTE EP6FIFOBUF[1024]  _AT_ 0xF800;  // 512/1024-byte EP6 buffer (IN or OUT)
 264      =1  EXTERN xdata volatile BYTE EP8FIFOBUF[1024]  _AT_ 0xFC00;  // 512 byte EP8 buffer (IN or OUT)
 265      =1  
 266      =1  // Error Correction Code (ECC) Registers (FX2LP/FX1 only)
 267      =1  
 268      =1  EXTERN xdata volatile BYTE ECCCFG            _AT_ 0xE628;  // ECC Configuration
 269      =1  EXTERN xdata volatile BYTE ECCRESET          _AT_ 0xE629;  // ECC Reset
 270      =1  EXTERN xdata volatile BYTE ECC1B0            _AT_ 0xE62A;  // ECC1 Byte 0
 271      =1  EXTERN xdata volatile BYTE ECC1B1            _AT_ 0xE62B;  // ECC1 Byte 1
 272      =1  EXTERN xdata volatile BYTE ECC1B2            _AT_ 0xE62C;  // ECC1 Byte 2
 273      =1  EXTERN xdata volatile BYTE ECC2B0            _AT_ 0xE62D;  // ECC2 Byte 0
 274      =1  EXTERN xdata volatile BYTE ECC2B1            _AT_ 0xE62E;  // ECC2 Byte 1
 275      =1  EXTERN xdata volatile BYTE ECC2B2            _AT_ 0xE62F;  // ECC2 Byte 2
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 11  

 276      =1  
 277      =1  // Feature Registers  (FX2LP/FX1 only)
 278      =1  EXTERN xdata volatile BYTE GPCR2             _AT_ 0xE50D;  // Chip Features
 279      =1  
 280      =1  #undef EXTERN
 281      =1  #undef _AT_
 282      =1  
 283      =1  /*-----------------------------------------------------------------------------
 284      =1     Special Function Registers (SFRs)
 285      =1     The byte registers and bits defined in the following list are based
 286      =1     on the Synopsis definition of the 8051 Special Function Registers for EZ-USB. 
 287      =1      If you modify the register definitions below, please regenerate the file 
 288      =1      "ezregs.inc" which includes the same basic information for assembly inclusion.
 289      =1  -----------------------------------------------------------------------------*/
 290      =1  
 291      =1  sfr IOA     = 0x80;
 292      =1           /*  IOA  */
 293      =1           sbit PA0    = 0x80 + 0;
 294      =1           sbit PA1    = 0x80 + 1;
 295      =1           sbit PA2    = 0x80 + 2;
 296      =1           sbit PA3    = 0x80 + 3;
 297      =1  
 298      =1           sbit PA4    = 0x80 + 4;
 299      =1           sbit PA5    = 0x80 + 5;
 300      =1           sbit PA6    = 0x80 + 6;
 301      =1           sbit PA7    = 0x80 + 7;
 302      =1  sfr SP      = 0x81;
 303      =1  sfr DPL     = 0x82;
 304      =1  sfr DPH     = 0x83;
 305      =1  sfr DPL1    = 0x84;
 306      =1  sfr DPH1    = 0x85;
 307      =1  sfr DPS     = 0x86;
 308      =1           /*  DPS  */
 309      =1           // sbit SEL   = 0x86+0;
 310      =1  sfr PCON    = 0x87;
 311      =1           /*  PCON  */
 312      =1           //sbit IDLE   = 0x87+0;
 313      =1           //sbit STOP   = 0x87+1;
 314      =1           //sbit GF0    = 0x87+2;
 315      =1           //sbit GF1    = 0x87+3;
 316      =1           //sbit SMOD0  = 0x87+7;
 317      =1  sfr TCON    = 0x88;
 318      =1           /*  TCON  */
 319      =1           sbit IT0    = 0x88+0;
 320      =1           sbit IE0    = 0x88+1;
 321      =1           sbit IT1    = 0x88+2;
 322      =1           sbit IE1    = 0x88+3;
 323      =1           sbit TR0    = 0x88+4;
 324      =1           sbit TF0    = 0x88+5;
 325      =1           sbit TR1    = 0x88+6;
 326      =1           sbit TF1    = 0x88+7;
 327      =1  sfr TMOD    = 0x89;
 328      =1           /*  TMOD  */
 329      =1           //sbit M00    = 0x89+0;
 330      =1           //sbit M10    = 0x89+1;
 331      =1           //sbit CT0    = 0x89+2;
 332      =1           //sbit GATE0  = 0x89+3;
 333      =1           //sbit M01    = 0x89+4;
 334      =1           //sbit M11    = 0x89+5;
 335      =1           //sbit CT1    = 0x89+6;
 336      =1           //sbit GATE1  = 0x89+7;
 337      =1  sfr TL0     = 0x8A;
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 12  

 338      =1  sfr TL1     = 0x8B;
 339      =1  sfr TH0     = 0x8C;
 340      =1  sfr TH1     = 0x8D;
 341      =1  sfr CKCON   = 0x8E;
 342      =1           /*  CKCON  */
 343      =1           //sbit MD0    = 0x89+0;
 344      =1           //sbit MD1    = 0x89+1;
 345      =1           //sbit MD2    = 0x89+2;
 346      =1           //sbit T0M    = 0x89+3;
 347      =1           //sbit T1M    = 0x89+4;
 348      =1           //sbit T2M    = 0x89+5;
 349      =1  sfr SPC_FNC = 0x8F; // Was WRS in Reg320
 350      =1           /*  CKCON  */
 351      =1           //sbit WRS    = 0x8F+0;
 352      =1  sfr IOB     = 0x90;
 353      =1           /*  IOB  */
 354      =1           sbit PB0    = 0x90 + 0;
 355      =1           sbit PB1    = 0x90 + 1;
 356      =1           sbit PB2    = 0x90 + 2;
 357      =1           sbit PB3    = 0x90 + 3;
 358      =1  
 359      =1           sbit PB4    = 0x90 + 4;
 360      =1           sbit PB5    = 0x90 + 5;
 361      =1           sbit PB6    = 0x90 + 6;
 362      =1           sbit PB7    = 0x90 + 7;
 363      =1  sfr EXIF    = 0x91; // EXIF Bit Values differ from Reg320
 364      =1           /*  EXIF  */
 365      =1           //sbit USBINT = 0x91+4;
 366      =1           //sbit I2CINT = 0x91+5;
 367      =1           //sbit IE4    = 0x91+6;
 368      =1           //sbit IE5    = 0x91+7;
 369      =1  sfr MPAGE  = 0x92;
 370      =1  sfr SCON0  = 0x98;
 371      =1           /*  SCON0  */
 372      =1           sbit RI    = 0x98+0;
 373      =1           sbit TI    = 0x98+1;
 374      =1           sbit RB8   = 0x98+2;
 375      =1           sbit TB8   = 0x98+3;
 376      =1           sbit REN   = 0x98+4;
 377      =1           sbit SM2   = 0x98+5;
 378      =1           sbit SM1   = 0x98+6;
 379      =1           sbit SM0   = 0x98+7;
 380      =1  sfr SBUF0  = 0x99;
 381      =1  
 382      =1  #define AUTOPTR1H AUTOPTRH1 // for backwards compatibility with examples
 383      =1  #define AUTOPTR1L AUTOPTRL1 // for backwards compatibility with examples
 384      =1  #define APTR1H AUTOPTRH1 // for backwards compatibility with examples
 385      =1  #define APTR1L AUTOPTRL1 // for backwards compatibility with examples
 386      =1  
 387      =1  // this is how they are defined in the TRM
 388      =1  sfr AUTOPTRH1     = 0x9A; 
 389      =1  sfr AUTOPTRL1     = 0x9B; 
 390      =1  sfr AUTOPTRH2     = 0x9D;
 391      =1  sfr AUTOPTRL2     = 0x9E; 
 392      =1  
 393      =1  sfr IOC        = 0xA0;
 394      =1           /*  IOC  */
 395      =1           sbit PC0    = 0xA0 + 0;
 396      =1           sbit PC1    = 0xA0 + 1;
 397      =1           sbit PC2    = 0xA0 + 2;
 398      =1           sbit PC3    = 0xA0 + 3;
 399      =1  
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 13  

 400      =1           sbit PC4    = 0xA0 + 4;
 401      =1           sbit PC5    = 0xA0 + 5;
 402      =1           sbit PC6    = 0xA0 + 6;
 403      =1           sbit PC7    = 0xA0 + 7;
 404      =1  sfr INT2CLR    = 0xA1;
 405      =1  sfr INT4CLR    = 0xA2;
 406      =1  
 407      =1  sfr IE     = 0xA8;
 408      =1           /*  IE  */
 409      =1           sbit EX0   = 0xA8+0;
 410      =1           sbit ET0   = 0xA8+1;
 411      =1           sbit EX1   = 0xA8+2;
 412      =1           sbit ET1   = 0xA8+3;
 413      =1           sbit ES0   = 0xA8+4;
 414      =1           sbit ET2   = 0xA8+5;
 415      =1           sbit ES1   = 0xA8+6;
 416      =1           sbit EA    = 0xA8+7;
 417      =1  
 418      =1  sfr EP2468STAT     = 0xAA;
 419      =1           /* EP2468STAT */
 420      =1           //sbit EP2E   = 0xAA+0;
 421      =1           //sbit EP2F   = 0xAA+1;
 422      =1           //sbit EP4E   = 0xAA+2;
 423      =1           //sbit EP4F   = 0xAA+3;
 424      =1           //sbit EP6E   = 0xAA+4;
 425      =1           //sbit EP6F   = 0xAA+5;
 426      =1           //sbit EP8E   = 0xAA+6;
 427      =1           //sbit EP8F   = 0xAA+7;
 428      =1  
 429      =1  sfr EP24FIFOFLGS   = 0xAB;
 430      =1  sfr EP68FIFOFLGS   = 0xAC;
 431      =1  sfr AUTOPTRSETUP  = 0xAF;
 432      =1           /* AUTOPTRSETUP */
 433      =1           //   sbit EXTACC  = 0xAF+0;
 434      =1           //   sbit APTR1FZ = 0xAF+1;
 435      =1           //   sbit APTR2FZ = 0xAF+2;
 436      =1  
 437      =1  sfr IOD     = 0xB0;
 438      =1           /*  IOD  */
 439      =1           sbit PD0    = 0xB0 + 0;
 440      =1           sbit PD1    = 0xB0 + 1;
 441      =1           sbit PD2    = 0xB0 + 2;
 442      =1           sbit PD3    = 0xB0 + 3;
 443      =1  
 444      =1           sbit PD4    = 0xB0 + 4;
 445      =1           sbit PD5    = 0xB0 + 5;
 446      =1           sbit PD6    = 0xB0 + 6;
 447      =1           sbit PD7    = 0xB0 + 7;
 448      =1  sfr IOE     = 0xB1;
 449      =1  sfr OEA     = 0xB2;
 450      =1  sfr OEB     = 0xB3;
 451      =1  sfr OEC     = 0xB4;
 452      =1  sfr OED     = 0xB5;
 453      =1  sfr OEE     = 0xB6;
 454      =1  
 455      =1  sfr IP     = 0xB8;
 456      =1           /*  IP  */
 457      =1           sbit PX0   = 0xB8+0;
 458      =1           sbit PT0   = 0xB8+1;
 459      =1           sbit PX1   = 0xB8+2;
 460      =1           sbit PT1   = 0xB8+3;
 461      =1           sbit PS0   = 0xB8+4;
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 14  

 462      =1           sbit PT2   = 0xB8+5;
 463      =1           sbit PS1   = 0xB8+6;
 464      =1  
 465      =1  sfr EP01STAT    = 0xBA;
 466      =1  sfr GPIFTRIG    = 0xBB;
 467      =1                  
 468      =1  sfr GPIFSGLDATH     = 0xBD;
 469      =1  sfr GPIFSGLDATLX    = 0xBE;
 470      =1  sfr GPIFSGLDATLNOX  = 0xBF;
 471      =1  
 472      =1  sfr SCON1  = 0xC0;
 473      =1           /*  SCON1  */
 474      =1           sbit RI1   = 0xC0+0;
 475      =1           sbit TI1   = 0xC0+1;
 476      =1           sbit RB81  = 0xC0+2;
 477      =1           sbit TB81  = 0xC0+3;
 478      =1           sbit REN1  = 0xC0+4;
 479      =1           sbit SM21  = 0xC0+5;
 480      =1           sbit SM11  = 0xC0+6;
 481      =1           sbit SM01  = 0xC0+7;
 482      =1  sfr SBUF1  = 0xC1;
 483      =1  sfr T2CON  = 0xC8;
 484      =1           /*  T2CON  */
 485      =1           sbit CP_RL2 = 0xC8+0;
 486      =1           sbit C_T2  = 0xC8+1;
 487      =1           sbit TR2   = 0xC8+2;
 488      =1           sbit EXEN2 = 0xC8+3;
 489      =1           sbit TCLK  = 0xC8+4;
 490      =1           sbit RCLK  = 0xC8+5;
 491      =1           sbit EXF2  = 0xC8+6;
 492      =1           sbit TF2   = 0xC8+7;
 493      =1  sfr RCAP2L = 0xCA;
 494      =1  sfr RCAP2H = 0xCB;
 495      =1  sfr TL2    = 0xCC;
 496      =1  sfr TH2    = 0xCD;
 497      =1  sfr PSW    = 0xD0;
 498      =1           /*  PSW  */
 499      =1           sbit P     = 0xD0+0;
 500      =1           sbit FL    = 0xD0+1;
 501      =1           sbit OV    = 0xD0+2;
 502      =1           sbit RS0   = 0xD0+3;
 503      =1           sbit RS1   = 0xD0+4;
 504      =1           sbit F0    = 0xD0+5;
 505      =1           sbit AC    = 0xD0+6;
 506      =1           sbit CY    = 0xD0+7;
 507      =1  sfr EICON  = 0xD8; // Was WDCON in DS80C320; Bit Values differ from Reg320
 508      =1           /*  EICON  */
 509      =1           sbit INT6  = 0xD8+3;
 510      =1           sbit RESI  = 0xD8+4;
 511      =1           sbit ERESI = 0xD8+5;
 512      =1           sbit SMOD1 = 0xD8+7;
 513      =1  sfr ACC    = 0xE0;
 514      =1  sfr EIE    = 0xE8; // EIE Bit Values differ from Reg320
 515      =1           /*  EIE  */
 516      =1           sbit EUSB    = 0xE8+0;
 517      =1           sbit EI2C    = 0xE8+1;
 518      =1           sbit EIEX4   = 0xE8+2;
 519      =1           sbit EIEX5   = 0xE8+3;
 520      =1           sbit EIEX6   = 0xE8+4;
 521      =1  sfr B      = 0xF0;
 522      =1  sfr EIP    = 0xF8; // EIP Bit Values differ from Reg320
 523      =1           /*  EIP  */
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 15  

 524      =1           sbit PUSB    = 0xF8+0;
 525      =1           sbit PI2C    = 0xF8+1;
 526      =1           sbit EIPX4   = 0xF8+2;
 527      =1           sbit EIPX5   = 0xF8+3;
 528      =1           sbit EIPX6   = 0xF8+4;
 529      =1  
 530      =1  /*-----------------------------------------------------------------------------
 531      =1     Bit Masks
 532      =1  -----------------------------------------------------------------------------*/
 533      =1  
 534      =1  /* CPU Control & Status Register (CPUCS) */
 535      =1  #define bmPRTCSTB    bmBIT5
 536      =1  #define bmCLKSPD     (bmBIT4 | bmBIT3)
 537      =1  #define bmCLKSPD1    bmBIT4
 538      =1  #define bmCLKSPD0    bmBIT3
 539      =1  #define bmCLKINV     bmBIT2
 540      =1  #define bmCLKOE      bmBIT1
 541      =1  #define bm8051RES    bmBIT0
 542      =1  /* Port Alternate Configuration Registers */
 543      =1  /* Port A (PORTACFG) */
 544      =1  #define bmFLAGD      bmBIT7
 545      =1  #define bmINT1       bmBIT1
 546      =1  #define bmINT0       bmBIT0
 547      =1  /* Port C (PORTCCFG) */
 548      =1  #define bmGPIFA7     bmBIT7
 549      =1  #define bmGPIFA6     bmBIT6
 550      =1  #define bmGPIFA5     bmBIT5
 551      =1  #define bmGPIFA4     bmBIT4
 552      =1  #define bmGPIFA3     bmBIT3
 553      =1  #define bmGPIFA2     bmBIT2
 554      =1  #define bmGPIFA1     bmBIT1
 555      =1  #define bmGPIFA0     bmBIT0
 556      =1  /* Port E (PORTECFG) */
 557      =1  #define bmGPIFA8     bmBIT7
 558      =1  #define bmT2EX       bmBIT6
 559      =1  #define bmINT6       bmBIT5
 560      =1  #define bmRXD1OUT    bmBIT4
 561      =1  #define bmRXD0OUT    bmBIT3
 562      =1  #define bmT2OUT      bmBIT2
 563      =1  #define bmT1OUT      bmBIT1
 564      =1  #define bmT0OUT      bmBIT0
 565      =1  
 566      =1  /* I2C Control & Status Register (I2CS) */
 567      =1  #define bmSTART      bmBIT7
 568      =1  #define bmSTOP       bmBIT6
 569      =1  #define bmLASTRD     bmBIT5
 570      =1  #define bmID         (bmBIT4 | bmBIT3)
 571      =1  #define bmBERR       bmBIT2
 572      =1  #define bmACK        bmBIT1
 573      =1  #define bmDONE       bmBIT0
 574      =1  /* I2C Control Register (I2CTL) */
 575      =1  #define bmSTOPIE     bmBIT1
 576      =1  #define bm400KHZ     bmBIT0
 577      =1  /* Interrupt 2 (USB) Autovector Register (INT2IVEC) */
 578      =1  #define bmIV4        bmBIT6
 579      =1  #define bmIV3        bmBIT5
 580      =1  #define bmIV2        bmBIT4
 581      =1  #define bmIV1        bmBIT3
 582      =1  #define bmIV0        bmBIT2
 583      =1  /* USB Interrupt Request & Enable Registers (USBIE/USBIRQ) */
 584      =1  #define bmEP0ACK     bmBIT6
 585      =1  #define bmHSGRANT    bmBIT5
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 16  

 586      =1  #define bmURES       bmBIT4
 587      =1  #define bmSUSP       bmBIT3
 588      =1  #define bmSUTOK      bmBIT2
 589      =1  #define bmSOF        bmBIT1
 590      =1  #define bmSUDAV      bmBIT0
 591      =1  /* Breakpoint register (BREAKPT) */
 592      =1  #define bmBREAK      bmBIT3
 593      =1  #define bmBPPULSE    bmBIT2
 594      =1  #define bmBPEN       bmBIT1
 595      =1  /* Interrupt 2 & 4 Setup (INTSETUP) */
 596      =1  #define bmAV2EN      bmBIT3
 597      =1  #define INT4IN       bmBIT1
 598      =1  #define bmAV4EN      bmBIT0
 599      =1  /* USB Control & Status Register (USBCS) */
 600      =1  #define bmHSM        bmBIT7
 601      =1  #define bmDISCON     bmBIT3
 602      =1  #define bmNOSYNSOF   bmBIT2
 603      =1  #define bmRENUM      bmBIT1
 604      =1  #define bmSIGRESUME  bmBIT0
 605      =1  /* Wakeup Control and Status Register (WAKEUPCS) */
 606      =1  #define bmWU2        bmBIT7
 607      =1  #define bmWU         bmBIT6
 608      =1  #define bmWU2POL     bmBIT5
 609      =1  #define bmWUPOL      bmBIT4
 610      =1  #define bmDPEN       bmBIT2
 611      =1  #define bmWU2EN      bmBIT1
 612      =1  #define bmWUEN       bmBIT0
 613      =1  /* End Point 0 Control & Status Register (EP0CS) */
 614      =1  #define bmHSNAK      bmBIT7
 615      =1  /* End Point 0-1 Control & Status Registers (EP0CS/EP1OUTCS/EP1INCS) */
 616      =1  #define bmEPBUSY     bmBIT1
 617      =1  #define bmEPSTALL    bmBIT0
 618      =1  /* End Point 2-8 Control & Status Registers (EP2CS/EP4CS/EP6CS/EP8CS) */
 619      =1  #define bmNPAK       (bmBIT6 | bmBIT5 | bmBIT4)
 620      =1  #define bmEPFULL     bmBIT3
 621      =1  #define bmEPEMPTY    bmBIT2
 622      =1  /* Endpoint Status (EP2468STAT) SFR bits */
 623      =1  #define bmEP8FULL    bmBIT7
 624      =1  #define bmEP8EMPTY   bmBIT6
 625      =1  #define bmEP6FULL    bmBIT5
 626      =1  #define bmEP6EMPTY   bmBIT4
 627      =1  #define bmEP4FULL    bmBIT3
 628      =1  #define bmEP4EMPTY   bmBIT2
 629      =1  #define bmEP2FULL    bmBIT1
 630      =1  #define bmEP2EMPTY   bmBIT0
 631      =1  /* SETUP Data Pointer Auto Mode (SUDPTRCTL) */
 632      =1  #define bmSDPAUTO    bmBIT0
 633      =1  /* Endpoint Data Toggle Control (TOGCTL) */
 634      =1  #define bmQUERYTOGGLE  bmBIT7
 635      =1  #define bmSETTOGGLE    bmBIT6
 636      =1  #define bmRESETTOGGLE  bmBIT5
 637      =1  #define bmTOGCTLEPMASK bmBIT3 | bmBIT2 | bmBIT1 | bmBIT0
 638      =1  /* IBN (In Bulk Nak) enable and request bits (IBNIE/IBNIRQ) */
 639      =1  #define bmEP8IBN     bmBIT5
 640      =1  #define bmEP6IBN     bmBIT4
 641      =1  #define bmEP4IBN     bmBIT3
 642      =1  #define bmEP2IBN     bmBIT2
 643      =1  #define bmEP1IBN     bmBIT1
 644      =1  #define bmEP0IBN     bmBIT0
 645      =1  
 646      =1  /* PING-NAK enable and request bits (NAKIE/NAKIRQ) */
 647      =1  #define bmEP8PING     bmBIT7
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 17  

 648      =1  #define bmEP6PING     bmBIT6
 649      =1  #define bmEP4PING     bmBIT5
 650      =1  #define bmEP2PING     bmBIT4
 651      =1  #define bmEP1PING     bmBIT3
 652      =1  #define bmEP0PING     bmBIT2
 653      =1  #define bmIBN         bmBIT0
 654      =1  
 655      =1  /* Interface Configuration bits (IFCONFIG) */
 656      =1  #define bmIFCLKSRC    bmBIT7
 657      =1  #define bm3048MHZ     bmBIT6
 658      =1  #define bmIFCLKOE     bmBIT5
 659      =1  #define bmIFCLKPOL    bmBIT4
 660      =1  #define bmASYNC       bmBIT3
 661      =1  #define bmGSTATE      bmBIT2
 662      =1  #define bmIFCFG1      bmBIT1
 663      =1  #define bmIFCFG0      bmBIT0
 664      =1  #define bmIFCFGMASK   (bmIFCFG0 | bmIFCFG1)
 665      =1  #define bmIFGPIF      bmIFCFG1
 666      =1  
 667      =1  /* EP 2468 FIFO Configuration bits (EP2FIFOCFG,EP4FIFOCFG,EP6FIFOCFG,EP8FIFOCFG) */
 668      =1  #define bmINFM       bmBIT6
 669      =1  #define bmOEP        bmBIT5
 670      =1  #define bmAUTOOUT    bmBIT4
 671      =1  #define bmAUTOIN     bmBIT3
 672      =1  #define bmZEROLENIN  bmBIT2
 673      =1  #define bmWORDWIDE   bmBIT0
 674      =1  
 675      =1  /* Chip Revision Control Bits (REVCTL) - used to ebable/disable revision specidic
 676      =1     features */ 
 677      =1  #define bmNOAUTOARM    bmBIT1
 678      =1  #define bmSKIPCOMMIT   bmBIT0
 679      =1  
 680      =1  /* Fifo Reset bits (FIFORESET) */
 681      =1  #define bmNAKALL       bmBIT7
 682      =1  
 683      =1  /* Chip Feature Register (GPCR2) */
 684      =1  #define bmFULLSPEEDONLY    bmBIT4
 685      =1  
 686      =1  #endif   /* FX2REGS_H */
   4          #include "FX2LPserial.h"
   1      =1  
   2      =1  #ifndef _INCLUDED_FX2LPSERIAL_H
   3      =1  #define _INCLUDED_FX2LPSERIAL_H
   4      =1  
   5      =1  #define FX2LP_SERIAL
   6      =1  #ifdef FX2LP_SERIAL
   7      =1  
   8      =1  
   9      =1  extern void FX2LPSerial_Init() ;
  10      =1  
  11      =1  extern void
  12      =1  FX2LPSerial_XmitChar(char ch) reentrant;
  13      =1  
  14      =1  extern void
  15      =1  FX2LPSerial_XmitHex1(BYTE b) ;
  16      =1  
  17      =1  extern void
  18      =1  FX2LPSerial_XmitHex2(BYTE b) ;
  19      =1  
  20      =1  extern void
  21      =1  FX2LPSerial_XmitHex4(WORD w) ;
  22      =1  
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 18  

  23      =1  extern void
  24      =1  FX2LPSerial_XmitString(char *str) reentrant;
  25      =1  
  26      =1  #endif
  27      =1  #endif
   5          
   6          void FX2LPSerial_Init()  // initializes the registers for using Timer2 as baud rate generator for a Baud r
             -ate of 38400.
   7          {
   8   1              T2CON = 0x34 ;
   9   1              RCAP2H  = 0xFF ;
  10   1              RCAP2L = 0xD9;
  11   1              SCON0 = 0x5A ;
  12   1              TI = 1;
  13   1      
  14   1      CPUCS = ((CPUCS & ~bmCLKSPD) | bmCLKSPD1) ;     //Setting up the clock frequency
  15   1      
  16   1      
  17   1              FX2LPSerial_XmitString("\r\n->Initialized.... \n\n") ;          //Clearing the output screen
  18   1               
  19   1      }
  20          
  21          void FX2LPSerial_XmitChar(char ch) reentrant // prints a character
  22          {
  23   1              while (TI == 0) ;
  24   1              TI = 0 ;
  25   1              SBUF0 = ch ;    //print the character
  26   1      }
  27          
  28          void FX2LPSerial_XmitHex1(BYTE b) // intermediate function to print the 4-bit nibble in hex format
  29          {
  30   1              if (b < 10)
  31   1                      FX2LPSerial_XmitChar(b + '0') ;
  32   1              else
  33   1                      FX2LPSerial_XmitChar(b - 10 + 'A') ;
  34   1      }
  35          
  36          void FX2LPSerial_XmitHex2(BYTE b) // prints the value of the BYTE variable in hex
  37          {
  38   1              FX2LPSerial_XmitHex1((b >> 4) & 0x0f) ;
  39   1              FX2LPSerial_XmitHex1(b & 0x0f) ;
  40   1      }
  41          
  42          void FX2LPSerial_XmitHex4(WORD w) // prints the value of the WORD variable in hex
  43          {
  44   1              FX2LPSerial_XmitHex2((w >> 8) & 0xff) ;
  45   1              FX2LPSerial_XmitHex2(w & 0xff) ;
  46   1      }
  47          
  48          void FX2LPSerial_XmitString(char *str) reentrant
  49          {
  50   1              while (*str)
  51   1                      FX2LPSerial_XmitChar(*str++) ;
  52   1      }
  53          
  54          
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 19  

ASSEMBLY LISTING OF GENERATED OBJECT CODE


             ; FUNCTION FX2LPSerial_Init (BEGIN)
                                           ; SOURCE LINE # 6
                                           ; SOURCE LINE # 7
                                           ; SOURCE LINE # 8
0000 75C834            MOV     T2CON,#034H
                                           ; SOURCE LINE # 9
0003 75CBFF            MOV     RCAP2H,#0FFH
                                           ; SOURCE LINE # 10
0006 75CAD9            MOV     RCAP2L,#0D9H
                                           ; SOURCE LINE # 11
0009 75985A            MOV     SCON0,#05AH
                                           ; SOURCE LINE # 12
000C D299              SETB    TI
                                           ; SOURCE LINE # 14
000E 900000      E     MOV     DPTR,#CPUCS
0011 E0                MOVX    A,@DPTR
0012 54E7              ANL     A,#0E7H
0014 4410              ORL     A,#010H
0016 F0                MOVX    @DPTR,A
                                           ; SOURCE LINE # 17
0017 7BFF              MOV     R3,#0FFH
0019 7A00        R     MOV     R2,#HIGH ?SC_0
001B 7900        R     MOV     R1,#LOW ?SC_0
001D 020000      R     LJMP    _?FX2LPSerial_XmitString
             ; FUNCTION FX2LPSerial_Init (END)

             ; FUNCTION _?FX2LPSerial_XmitChar (BEGIN)
                                           ; SOURCE LINE # 21
0000 1500        E     DEC     ?C_IBP
0002 A800        E     MOV     R0,?C_IBP
0004 A607              MOV     @R0,AR7
0006         ?C0002:
                                           ; SOURCE LINE # 23
0006 3099FD            JNB     TI,?C0002
0009         ?C0003:
                                           ; SOURCE LINE # 24
0009 C299              CLR     TI
                                           ; SOURCE LINE # 25
000B A800        E     MOV     R0,?C_IBP
000D E6                MOV     A,@R0
000E F599              MOV     SBUF0,A
                                           ; SOURCE LINE # 26
0010 0500        E     INC     ?C_IBP
0012 22                RET     
             ; FUNCTION _?FX2LPSerial_XmitChar (END)

             ; FUNCTION _FX2LPSerial_XmitHex1 (BEGIN)
                                           ; SOURCE LINE # 28
;---- Variable 'b' assigned to Register 'R6' ----
0000 AE07              MOV     R6,AR7
                                           ; SOURCE LINE # 29
                                           ; SOURCE LINE # 30
0002 EE                MOV     A,R6
0003 C3                CLR     C
0004 940A              SUBB    A,#0AH
0006 EE                MOV     A,R6
0007 5004              JNC     ?C0005
                                           ; SOURCE LINE # 31
0009 2430              ADD     A,#030H
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 20  

000B 8002              SJMP    ?C0014
000D         ?C0005:
                                           ; SOURCE LINE # 33
000D 2437              ADD     A,#037H
000F         ?C0014:
000F FF                MOV     R7,A
0010 120000      R     LCALL   _?FX2LPSerial_XmitChar
                                           ; SOURCE LINE # 34
0013         ?C0007:
0013 22                RET     
             ; FUNCTION _FX2LPSerial_XmitHex1 (END)

             ; FUNCTION _FX2LPSerial_XmitHex2 (BEGIN)
                                           ; SOURCE LINE # 36
;---- Variable 'b' assigned to Register 'R5' ----
0000 AD07              MOV     R5,AR7
                                           ; SOURCE LINE # 37
                                           ; SOURCE LINE # 38
0002 ED                MOV     A,R5
0003 C4                SWAP    A
0004 540F              ANL     A,#0FH
0006 FF                MOV     R7,A
0007 120000      R     LCALL   _FX2LPSerial_XmitHex1
                                           ; SOURCE LINE # 39
000A ED                MOV     A,R5
000B 540F              ANL     A,#0FH
000D FF                MOV     R7,A
000E 020000      R     LJMP    _FX2LPSerial_XmitHex1
             ; FUNCTION _FX2LPSerial_XmitHex2 (END)

             ; FUNCTION _FX2LPSerial_XmitHex4 (BEGIN)
                                           ; SOURCE LINE # 42
;---- Variable 'w' assigned to Register 'R2/R3' ----
0000 AB07              MOV     R3,AR7
0002 AA06              MOV     R2,AR6
                                           ; SOURCE LINE # 43
                                           ; SOURCE LINE # 44
0004 AF02              MOV     R7,AR2
0006 120000      R     LCALL   _FX2LPSerial_XmitHex2
                                           ; SOURCE LINE # 45
0009 AF03              MOV     R7,AR3
000B 020000      R     LJMP    _FX2LPSerial_XmitHex2
             ; FUNCTION _FX2LPSerial_XmitHex4 (END)

             ; FUNCTION _?FX2LPSerial_XmitString (BEGIN)
                                           ; SOURCE LINE # 48
0000 1500        E     DEC     ?C_IBP
0002 1500        E     DEC     ?C_IBP
0004 1500        E     DEC     ?C_IBP
0006 A800        E     MOV     R0,?C_IBP
0008 A603              MOV     @R0,AR3
000A 08                INC     R0
000B A602              MOV     @R0,AR2
000D 08                INC     R0
000E A601              MOV     @R0,AR1
0010         ?C0010:
                                           ; SOURCE LINE # 50
0010 A800        E     MOV     R0,?C_IBP
0012 8603              MOV     AR3,@R0
0014 08                INC     R0
0015 E6                MOV     A,@R0
0016 FA                MOV     R2,A
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 21  

0017 08                INC     R0
0018 E6                MOV     A,@R0
0019 F9                MOV     R1,A
001A 120000      E     LCALL   ?C?CLDPTR
001D 6019              JZ      ?C0012
                                           ; SOURCE LINE # 51
001F A800        E     MOV     R0,?C_IBP
0021 8603              MOV     AR3,@R0
0023 08                INC     R0
0024 08                INC     R0
0025 06                INC     @R0
0026 E6                MOV     A,@R0
0027 18                DEC     R0
0028 8602              MOV     AR2,@R0
002A 7001              JNZ     ?C0013
002C 06                INC     @R0
002D         ?C0013:
002D 14                DEC     A
002E F9                MOV     R1,A
002F 120000      E     LCALL   ?C?CLDPTR
0032 FF                MOV     R7,A
0033 120000      R     LCALL   _?FX2LPSerial_XmitChar
0036 80D8              SJMP    ?C0010
                                           ; SOURCE LINE # 52
0038         ?C0012:
0038 0500        E     INC     ?C_IBP
003A 0500        E     INC     ?C_IBP
003C 0500        E     INC     ?C_IBP
003E 22                RET     
             ; FUNCTION _?FX2LPSerial_XmitString (END)

C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 22  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


CPUCS. . . . . . . . . . . . . . . . .  EXTERN   XDATA  U_CHAR   -----  1
DWORD. . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_LONG   -----  4
STRINGDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
DEVICEQUALDSCR . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  10
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  spec_ver_minor . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  spec_ver_major . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  dev_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  max_packet . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  configs. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
  reserved0. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0009H  1
TI . . . . . . . . . . . . . . . . . .  ABSBIT   -----  BIT      0099H  1
RCAP2H . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CBH  1
RCAP2L . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00CAH  1
DSCR . . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
BOOL . . . . . . . . . . . . . . . . .  TYPEDEF  DATA   BIT      -----  1
_FX2LPSerial_XmitHex1. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  b. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0006H  1
_FX2LPSerial_XmitHex2. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  b. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_CHAR   0005H  1
_FX2LPSerial_XmitHex4. . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  w. . . . . . . . . . . . . . . . . .  * REG *  DATA   U_INT    0002H  2
BYTE . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_CHAR   -----  1
WORD . . . . . . . . . . . . . . . . .  TYPEDEF  -----  U_INT    -----  2
FX2LPSerial_Init . . . . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
_?FX2LPSerial_XmitString . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  str. . . . . . . . . . . . . . . . .  AUTO     IDATA  PTR      0000H  3
_?FX2LPSerial_XmitChar . . . . . . . .  PUBLIC   CODE   PROC     0000H  -----
  ch . . . . . . . . . . . . . . . . .  AUTO     IDATA  CHAR     0000H  1
DEVICEDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  18
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  spec_ver_minor . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  spec_ver_major . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  dev_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  max_packet . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  vendor_id. . . . . . . . . . . . . .  MEMBER   -----  U_INT    0008H  2
  product_id . . . . . . . . . . . . .  MEMBER   -----  U_INT    000AH  2
  version_id . . . . . . . . . . . . .  MEMBER   -----  U_INT    000CH  2
  mfg_str. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000EH  1
  prod_str . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   000FH  1
  serialnum_str. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0010H  1
  configs. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0011H  1
SBUF0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0099H  1
SCON0. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   0098H  1
CONFIGDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
C51 COMPILER V9.01   FX2LPSERIAL                                                           08/11/2015 02:23:24 PAGE 23  

NAME                                    CLASS   MSPACE  TYPE    OFFSET  SIZE
====                                    =====   ======  ====    ======  ====


  config_len . . . . . . . . . . . . .  MEMBER   -----  U_INT    0002H  2
  interfaces . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  index. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  config_str . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  attrib . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  power. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
T2CON. . . . . . . . . . . . . . . . .  SFR      DATA   U_CHAR   00C8H  1
EPIOC. . . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  2
  cntrl. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  bytes. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
I2CPCKT. . . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  6
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  dat. . . . . . . . . . . . . . . . .  MEMBER   -----  PTR      0001H  3
  count. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  status . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
INTRFCDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  9
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  index. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  alt_setting. . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  ep_cnt . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  class. . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  sub_class. . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1
  protocol . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0007H  1
  interface_str. . . . . . . . . . . .  MEMBER   -----  U_CHAR   0008H  1
ENDPNTDSCR . . . . . . . . . . . . . .  TYPEDEF  -----  STRUCT   -----  7
  length . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0000H  1
  type . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0001H  1
  addr . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0002H  1
  ep_type. . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0003H  1
  mp_L . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0004H  1
  mp_H . . . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0005H  1
  interval . . . . . . . . . . . . . .  MEMBER   -----  U_CHAR   0006H  1


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    165    ----
   CONSTANT SIZE    =     23    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
